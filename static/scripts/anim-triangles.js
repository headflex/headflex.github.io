function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor}(function(){var vertexShader=function vertexShader(){return"\n      precision highp float;\n      uniform float time;\n      uniform mat4 modelViewMatrix;\n      uniform mat4 projectionMatrix;\n      attribute vec3 position;\n      attribute vec3 offset;\n      attribute vec4 color;\n      attribute vec4 orientationStart;\n      attribute vec4 orientationEnd;\n      attribute float timeOffset;\n      varying vec3 vPosition;\n      varying vec4 vColor;\n      varying float lifeProgress;\n\n      void main(){\n\n        vPosition = offset;\n\n        lifeProgress = mod(time+timeOffset,1.0);\n\n        vPosition = offset * lifeProgress + position;\n        vec4 orientation = normalize(mix(orientationStart, orientationEnd, lifeProgress));\n        vec3 vcV = cross(orientation.xyz, vPosition);\n        vPosition = vcV * (2.0 * orientation.w) + (cross(orientation.xyz, vcV) * 2.0 + vPosition);\n        vColor = color;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );\n      }"};var fragmentShader=function fragmentShader(){return"\n      precision highp float;\n      uniform float time;\n      varying vec3 vPosition;\n      varying vec4 vColor;\n      varying float lifeProgress;\n\n      void main() {\n        float depth = gl_FragCoord.z / gl_FragCoord.w / 5.0;\n        float opacity = clamp(0.2, 1.0, depth);\n        vec4 color = vColor;\n        color.a = sin(lifeProgress*100.0)*opacity;\n        gl_FragColor = color;\n      }"};var ParticleSystem=function(){function ParticleSystem(){_classCallCheck(this,ParticleSystem);this.time=0;var triangles=1;var instances=2e4;var geometry=new THREE.InstancedBufferGeometry;var vertices=new THREE.BufferAttribute(new Float32Array(triangles*3*3),3);var unit=.15;vertices.setXYZ(0,unit,-unit,0);vertices.setXYZ(1,-unit,unit,0);vertices.setXYZ(2,0,0,unit);geometry.addAttribute("position",vertices);var offsets=new THREE.InstancedBufferAttribute(new Float32Array(instances*3),3,1);var dist=80;for(var i=0,ul=offsets.count;i<ul;i++){offsets.setXYZ(i,(Math.random()-.5)*dist,(Math.random()-.5)*dist,(Math.random()-.5)*dist)}geometry.addAttribute("offset",offsets);var colors=new THREE.InstancedBufferAttribute(new Float32Array(instances*4),4,1);var threeColor=new THREE.Color;for(var _i=0,_ul=colors.count;_i<_ul;_i++){var c=threeColor.setHex(16753859);colors.setXYZW(_i,c.r,c.g,c.b,1)}geometry.addAttribute("color",colors);var timeOffsets=new THREE.InstancedBufferAttribute(new Float32Array(instances*1),1,1);for(var _i2=0,_ul2=timeOffsets.count;_i2<_ul2;_i2++){timeOffsets.setX(_i2,Math.random())}geometry.addAttribute("timeOffset",timeOffsets);var vector=new THREE.Vector4;var orientationsStart=new THREE.InstancedBufferAttribute(new Float32Array(instances*4),4,1);for(var _i3=0,_ul3=orientationsStart.count;_i3<_ul3;_i3++){vector.set(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1,Math.random()*2-1);vector.normalize();orientationsStart.setXYZW(_i3,vector.x,vector.y,vector.z,vector.w)}geometry.addAttribute("orientationStart",orientationsStart);var orientationsEnd=new THREE.InstancedBufferAttribute(new Float32Array(instances*4),4,1);for(var _i4=0,_ul4=orientationsEnd.count;_i4<_ul4;_i4++){vector.set(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1,Math.random()*2-1);vector.normalize();orientationsEnd.setXYZW(_i4,vector.x,vector.y,vector.z,vector.w)}geometry.addAttribute("orientationEnd",orientationsEnd);var material=new THREE.RawShaderMaterial({uniforms:{time:{value:1}},vertexShader:vertexShader(),fragmentShader:fragmentShader(),side:THREE.DoubleSide,transparent:true});var mesh=new THREE.Mesh(geometry,material);mesh.frustumCulled=false;this.mesh=mesh}_createClass(ParticleSystem,[{key:"update",value:function update(dt){this.time+=1e-4;this.mesh.material.uniforms.time.value=Math.sin(this.time)}}]);return ParticleSystem}();var size={width:window.innerWidth,height:window.innerHeight};var canvas=document.getElementById("anim-triangles");canvas.width=size.width;canvas.height=size.height;var renderer=new THREE.WebGLRenderer({canvas:canvas,antialias:true,alpha:true});renderer.setClearColor(16777215,0);var camera=new THREE.PerspectiveCamera(35,size.width/size.height,1,4500);var scene=new THREE.Scene;scene.add(camera);var particleSystem=new ParticleSystem;particleSystem.mesh.position.y=0;scene.add(particleSystem.mesh);var animate=function animate(){requestAnimationFrame(animate);render()};var render=function render(){particleSystem.update();renderer.render(scene,camera)};animate()})();